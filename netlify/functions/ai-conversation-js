// AI Conversation Handler for German Learning
exports.handler = async (event, context) => {
  // Only accept POST requests
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'POST, OPTIONS'
      }
    };
  }

  try {
    const { message, context: conversationContext, history } = JSON.parse(event.body);
    
    // Validate input
    if (!message) {
      return {
        statusCode: 400,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ error: 'Message is required' })
      };
    }

    // Prepare the system prompt based on user level and podcast context
    const systemPrompt = generateSystemPrompt(conversationContext);
    
    // Check if we have an API key
    const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;
    
    if (!ANTHROPIC_API_KEY) {
      // Return a mock response if no API key is configured
      console.log('No Anthropic API key found, returning mock response');
      return {
        statusCode: 200,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          text: getMockResponse(message, conversationContext),
          corrections: getMockCorrections(message),
          metrics: {
            accuracy: 85,
            fluency: 70,
            complexity: 60,
            vocabulary_usage: 75,
            grammar_accuracy: 80
          }
        })
      };
    }

    // Call Claude API
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': ANTHROPIC_API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-haiku-20240307', // Using Haiku for cost efficiency
        max_tokens: 500,
        messages: [
          { role: 'system', content: systemPrompt },
          ...formatConversationHistory(history),
          { role: 'user', content: message }
        ],
        temperature: 0.7
      })
    });

    if (!response.ok) {
      throw new Error(`Claude API error: ${response.status}`);
    }

    const data = await response.json();
    
    // Extract the response
    const aiResponse = data.content[0].text;
    
    // Analyze grammar
    const corrections = analyzeGrammar(message, conversationContext?.userLevel || 'B2');
    
    // Calculate performance metrics
    const metrics = calculatePerformanceMetrics(message, corrections, conversationContext);
    
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        text: aiResponse,
        corrections: corrections,
        metrics: metrics,
        suggestions: generateNextSteps(metrics, conversationContext)
      })
    };

  } catch (error) {
    console.error('AI Conversation Error:', error);
    return {
      statusCode: 500,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ 
        error: 'Internal server error',
        message: error.message 
      })
    };
  }
};

function generateSystemPrompt(context) {
  const { podcast, userLevel, focusAreas } = context || {};
  
  return `You are an expert German language teacher having a conversation with a ${userLevel || 'B2'} level student.

Current Context:
- The student just listened to a podcast episode: "${podcast?.title || 'German podcast'}"
- Podcast topic: ${podcast?.category || 'general'}
- Student's weak areas: ${focusAreas?.join(', ') || 'general improvement'}

Your role:
1. Speak primarily in German, appropriate for their ${userLevel || 'B2'} level
2. Gently correct grammar mistakes without interrupting the flow
3. Introduce vocabulary from the podcast naturally
4. Ask follow-up questions about what they understood
5. Explain grammar concepts when relevant
6. Encourage and motivate the student
7. If they struggle, provide hints rather than direct translations

Remember to:
- Use simple German for A2-B1 students
- Use more complex structures for B2+ students
- Always stay positive and encouraging
- Reference specific parts of the podcast when relevant`;
}

function getMockResponse(message, context) {
  const responses = {
    greeting: "Hallo! Schön, dass du hier bist! Ich bin dein KI-Deutschlehrer. Erzähl mir, was du heute gelernt hast oder stelle mir eine Frage über die deutsche Sprache!",
    
    podcast: "Das ist sehr interessant! Der Podcast über Technologie war wirklich spannend, nicht wahr? Was war für dich das wichtigste Thema? Hast du alle Fachbegriffe verstanden?",
    
    grammar: "Gute Frage! Lass mich das erklären. Im Deutschen verwenden wir das Perfekt für vergangene Ereignisse im Gespräch. Zum Beispiel: 'Ich habe gestern einen Podcast gehört.' Möchtest du das üben?",
    
    vocabulary: "Diese Wörter sind wichtig! 'Künstliche Intelligenz' bedeutet 'artificial intelligence'. Kannst du einen Satz damit bilden? Versuch es mal!",
    
    default: "Das ist eine gute Überlegung! Im Podcast haben wir über ähnliche Themen gesprochen. Was denkst du darüber? Lass uns das auf Deutsch diskutieren!"
  };

  // Simple keyword matching for mock responses
  const messageLower = message.toLowerCase();
  
  if (messageLower.includes('hallo') || messageLower.includes('guten')) {
    return responses.greeting;
  } else if (messageLower.includes('podcast')) {
    return responses.podcast;
  } else if (messageLower.includes('grammatik') || messageLower.includes('grammar')) {
    return responses.grammar;
  } else if (messageLower.includes('wort') || messageLower.includes('vokabel')) {
    return responses.vocabulary;
  }
  
  return responses.default;
}

function getMockCorrections(message) {
  const corrections = [];
  
  // Simple pattern matching for common German errors
  if (message.match(/\bich\s+habe\s+gegangen\b/i)) {
    corrections.push({
      original: 'ich habe gegangen',
      corrected: 'ich bin gegangen',
      explanation: 'Bewegungsverben bilden das Perfekt mit "sein"',
      type: 'grammar'
    });
  }
  
  if (message.match(/\bder\s+frau\b/i)) {
    corrections.push({
      original: 'der Frau',
      corrected: 'die Frau',
      explanation: '"Frau" ist feminin und braucht den Artikel "die"',
      type: 'grammar'
    });
  }
  
  return corrections;
}

function analyzeGrammar(text, userLevel) {
  const corrections = [];
  
  // Common German grammar patterns to check
  const patterns = [
    {
      pattern: /\bich\s+habe\s+gestern\s+gegangen\b/i,
      correction: 'ich bin gestern gegangen',
      explanation: 'Use "sein" for movement verbs in Perfekt'
    },
    {
      pattern: /\bder\s+frau\b/i,
      correction: 'die Frau',
      explanation: '"Frau" is feminine (die)'
    },
    {
      pattern: /\bich\s+will\s+zu\s+gehen\b/i,
      correction: 'ich will gehen',
      explanation: 'No "zu" needed after modal verbs'
    }
  ];
  
  patterns.forEach(({ pattern, correction, explanation }) => {
    const match = text.match(pattern);
    if (match) {
      corrections.push({
        original: match[0],
        corrected: correction,
        explanation: explanation,
        type: 'grammar'
      });
    }
  });
  
  return corrections;
}

function calculatePerformanceMetrics(message, corrections, context) {
  const wordCount = message.split(' ').length;
  const errorRate = corrections.length / Math.max(wordCount, 1);
  const complexity = assessComplexity(message);
  
  return {
    accuracy: Math.max(0, Math.round(100 - (errorRate * 100))),
    fluency: wordCount > 10 ? 80 : 60,
    complexity: complexity,
    vocabulary_usage: assessVocabularyUsage(message, context?.podcast),
    grammar_accuracy: Math.max(0, 100 - (corrections.filter(c => c.type === 'grammar').length * 10))
  };
}

function assessComplexity(text) {
  let score = 50; // Base score
  
  // Check for complex structures
  if (text.includes('weil') || text.includes('dass')) score += 10;
  if (text.includes('hätte') || text.includes('würde')) score += 15;
  if (text.match(/\b\w{12,}\b/)) score += 5; // Long words
  
  return Math.min(100, score);
}

function assessVocabularyUsage(message, podcast) {
  // Simple assessment based on message length and complexity
  const words = message.split(' ');
  const uniqueWords = new Set(words.map(w => w.toLowerCase()));
  
  return Math.min(100, Math.round((uniqueWords.size / words.length) * 100));
}

function generateNextSteps(metrics, context) {
  const suggestions = [];
  
  if (metrics.accuracy < 70) {
    suggestions.push({
      type: 'grammar',
      action: 'Review basic sentence structure',
      resource: 'grammar-drill?topic=sentence-structure'
    });
  }
  
  if (metrics.vocabulary_usage < 50) {
    suggestions.push({
      type: 'vocabulary',
      action: 'Practice podcast vocabulary',
      resource: 'vocabulary-flashcards'
    });
  }
  
  if (metrics.fluency < 70) {
    suggestions.push({
      type: 'speaking',
      action: 'Practice speaking exercises',
      resource: 'speaking-practice'
    });
  }
  
  return suggestions;
}

function formatConversationHistory(history) {
  if (!history || !Array.isArray(history)) return [];
  
  return history.map(msg => ({
    role: msg.sender === 'user' ? 'user' : 'assistant',
    content: msg.text
  }));
}
